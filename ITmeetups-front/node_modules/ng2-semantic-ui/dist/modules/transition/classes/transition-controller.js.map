{"version":3,"file":"transition-controller.js","sourceRoot":"","sources":["../../../../src/modules/transition/classes/transition-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { Renderer2, ElementRef, ChangeDetectorRef } from \"@angular/core\";\r\nimport { Transition, TransitionDirection } from \"./transition\";\r\n\r\nexport class TransitionController {\r\n    private _renderer:Renderer2;\r\n\r\n    private _element:ElementRef;\r\n\r\n    private _changeDetector:ChangeDetectorRef;\r\n\r\n    // Used to delay animations until we have an element to animate.\r\n    private get _isReady():boolean {\r\n        return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;\r\n    }\r\n\r\n    // Sets the 'display' style when visible.\r\n    private _display:string;\r\n\r\n    // Stores queued transitions.\r\n    private _queue:Transition[];\r\n\r\n    private _isAnimating:boolean;\r\n\r\n    public get isAnimating():boolean {\r\n        return this._isAnimating;\r\n    }\r\n\r\n    // Set when the element is visible, and while it is transitioning out.\r\n    private _isVisible:boolean;\r\n\r\n    public get isVisible():boolean {\r\n        return this._isVisible;\r\n    }\r\n\r\n    // Set when the element is hidden, and not while it is transitioning.\r\n    private _isHidden:boolean;\r\n\r\n    public get isHidden():boolean {\r\n        return this._isHidden;\r\n    }\r\n\r\n    // Gets the first transition in the queue.\r\n    private get _queueFirst():Transition {\r\n        return this._queue[0];\r\n    }\r\n\r\n    // Gets the last transition in the queue.\r\n    private get _queueLast():Transition {\r\n        return this._queue[this._queue.length - 1];\r\n    }\r\n\r\n    // Stores the setTimeout pointer for cancelling the animation callback.\r\n    private _animationTimeout:number;\r\n\r\n    constructor(isInitiallyVisible:boolean = true, display:string = \"block\") {\r\n        // isInitiallyVisible sets whether the element starts out visible.\r\n        this._isVisible = isInitiallyVisible;\r\n        this._isHidden = !this._isVisible;\r\n\r\n        this._display = display;\r\n        this._queue = [];\r\n\r\n        this._isAnimating = false;\r\n    }\r\n\r\n    // Sets the renderer to be used for animating.\r\n    public registerRenderer(renderer:Renderer2):void {\r\n        this._renderer = renderer;\r\n        this.performTransition();\r\n    }\r\n\r\n    // Sets the element to perform the animations on.\r\n    public registerElement(element:ElementRef):void {\r\n        this._element = element;\r\n        this.performTransition();\r\n    }\r\n\r\n    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\r\n    public registerChangeDetector(changeDetector:ChangeDetectorRef):void {\r\n        this._changeDetector = changeDetector;\r\n        this.performTransition();\r\n    }\r\n\r\n    public animate(transition:Transition):void {\r\n        // Test if transition is one of the list that doesn't change the visible state.\r\n        // Should these eventually become classes?\r\n        const isDirectionless = [\"jiggle\", \"flash\", \"shake\", \"pulse\", \"tada\", \"bounce\"].indexOf(transition.type) !== -1;\r\n        if (isDirectionless) {\r\n            transition.direction = TransitionDirection.Static;\r\n        } else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {\r\n            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.\r\n            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;\r\n            if (this._queueLast) {\r\n                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.\r\n                if (this._queueLast.direction === TransitionDirection.In) {\r\n                    transition.direction = TransitionDirection.Out;\r\n                } else if (this._queueLast.direction === TransitionDirection.Out) {\r\n                    transition.direction = TransitionDirection.In;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store the transition in the queue before attempting to perform it.\r\n        this._queue.push(transition);\r\n\r\n        this.performTransition();\r\n    }\r\n\r\n    private performTransition():void {\r\n        if (!this._isReady || this._isAnimating || !this._queueFirst) {\r\n            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.\r\n            return;\r\n        }\r\n\r\n        this._isAnimating = true;\r\n\r\n        const transition = this._queueFirst;\r\n\r\n        // Set the Semantic UI classes for transitioning.\r\n        transition.classes.forEach(c => this._renderer.addClass(this._element, c));\r\n        this._renderer.addClass(this._element, `animating`);\r\n        this._renderer.addClass(this._element, transition.directionClass);\r\n\r\n        // Set the Semantic UI styles for transitioning.\r\n        this._renderer.setStyle(this._element, `animationDuration`, `${transition.duration}ms`);\r\n        this._renderer.setStyle(this._element, `display`, this._display);\r\n\r\n        if (transition.direction === TransitionDirection.In) {\r\n            // Unset hidden if we are transitioning in.\r\n            this._isHidden = false;\r\n        }\r\n\r\n        // Wait the length of the animation before calling the complete callback.\r\n        this._animationTimeout = window.setTimeout(() => this.finishTransition(transition), transition.duration);\r\n    }\r\n\r\n    // Called when a transition has completed.\r\n    private finishTransition(transition:Transition):void {\r\n        // Unset the Semantic UI classes & styles for transitioning.\r\n        transition.classes.forEach(c => this._renderer.removeClass(this._element, c));\r\n        this._renderer.removeClass(this._element, `animating`);\r\n        this._renderer.removeClass(this._element, transition.directionClass);\r\n\r\n        this._renderer.removeStyle(this._element, `animationDuration`);\r\n        this._renderer.removeStyle(this._element, `display`);\r\n\r\n        if (transition.direction === TransitionDirection.In) {\r\n            // If we have just animated in, we are now visible.\r\n            this._isVisible = true;\r\n        } else if (transition.direction === TransitionDirection.Out) {\r\n            // If we have transitioned out, we should be invisible and hidden.\r\n            this._isVisible = false;\r\n            this._isHidden = true;\r\n        }\r\n\r\n        if (transition.onComplete) {\r\n            // Call the user-defined transition callback.\r\n            transition.onComplete();\r\n        }\r\n\r\n        // Delete the transition from the queue.\r\n        this._queue.shift();\r\n        this._isAnimating = false;\r\n\r\n        this._changeDetector.markForCheck();\r\n\r\n        // Immediately attempt to perform another transition.\r\n        this.performTransition();\r\n    }\r\n\r\n    // Stops the current transition, leaves the rest of the queue intact.\r\n    public stop(transition:Transition = this._queueFirst):void {\r\n        if (!transition || !this._isAnimating) {\r\n            return;\r\n        }\r\n\r\n        clearTimeout(this._animationTimeout);\r\n        this.finishTransition(transition);\r\n    }\r\n\r\n    // Stops the current transition, and empties the queue.\r\n    public stopAll():void {\r\n        this.clearQueue();\r\n        this.stop();\r\n    }\r\n\r\n    // Empties the transition queue but carries on with the current transition.\r\n    public clearQueue():void {\r\n        if (this.isAnimating) {\r\n            this._queue = [this._queueFirst];\r\n            return;\r\n        }\r\n        this._queue = [];\r\n    }\r\n}\r\n"]}