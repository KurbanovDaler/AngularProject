{"version":3,"file":"tabset.js","sourceRoot":"","sources":["../../../../src/modules/tabs/components/tabset.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, ContentChildren, QueryList, AfterContentInit } from \"@angular/core\";\r\nimport { SuiTabHeader } from \"../directives/tab-header\";\r\nimport { SuiTabContent } from \"../directives/tab-content\";\r\nimport { Tab } from \"../classes/tab\";\r\n\r\n@Component({\r\n    selector: \"sui-tabset\",\r\n    template: `<ng-content></ng-content>`\r\n})\r\nexport class SuiTabset implements AfterContentInit {\r\n    @ContentChildren(SuiTabHeader)\r\n    private _tabHeaders:QueryList<SuiTabHeader>;\r\n\r\n    @ContentChildren(SuiTabContent)\r\n    private _tabContents:QueryList<SuiTabContent>;\r\n\r\n    // List of all tabs in the tabset.\r\n    public tabs:Tab[];\r\n\r\n    // Keeps track of the currently active tab.\r\n    private _activeTab:Tab;\r\n\r\n    public get activeTab():Tab {\r\n        return this._activeTab;\r\n    }\r\n\r\n    // When setting a tab as the currently active tab, it automatically gains\r\n    // `isActive` status (saves littering `isActive = true` everywhere).\r\n    public set activeTab(tab:Tab) {\r\n        this._activeTab = tab;\r\n        tab.isActive = true;\r\n    }\r\n\r\n    // Keeps track of the number of times `internalComponentsUpdated` is called.\r\n    private _barrierCount:number;\r\n\r\n    constructor() {\r\n        this.tabs = [];\r\n        this._barrierCount = 0;\r\n    }\r\n\r\n    public ngAfterContentInit():void {\r\n        // Fire `internalComponentsUpdated` when the query lists change.\r\n        this._tabHeaders.changes.subscribe(() => this.internalComponentsUpdated());\r\n        this._tabContents.changes.subscribe(() => this.internalComponentsUpdated());\r\n\r\n        // Initially load the tabs.\r\n        this.loadTabs();\r\n    }\r\n\r\n    // Fires whenever either the tab headers or tab contents query lists update.\r\n    private internalComponentsUpdated():void {\r\n        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.\r\n        // This is so that both the headers and contents query lists can update before we run code that matches the two up.\r\n        this._barrierCount++;\r\n\r\n        if (this._barrierCount === 2) {\r\n            // Reset the barrier so it can be called again.\r\n            this._barrierCount = 0;\r\n\r\n            // Update the tabs.\r\n            this.loadTabs();\r\n        }\r\n    }\r\n\r\n    // Connects tab headers to tab contents, and creates a tab instance for each pairing.\r\n    private loadTabs():void {\r\n        // Remove any tabs that no longer have an associated header.\r\n        this.tabs = this.tabs.filter(t => !!this._tabHeaders.find(tH => tH === t.header));\r\n\r\n        this._tabHeaders\r\n            // Filter out the loaded headers with attached tab instances.\r\n            .filter(tH => !this.tabs.find(t => t.header === tH))\r\n            .forEach(tH => {\r\n                const content = this._tabContents.find(tC => tC.id === tH.id);\r\n\r\n                if (!content) {\r\n                    // Error if an associated tab content cannot be found for the given header.\r\n                    throw new Error(\"A [suiTabHeader] must have a related [suiTabContent].\");\r\n                }\r\n\r\n                // Create a new tab instance for this header & content combo.\r\n                const tab = new Tab(tH, content);\r\n\r\n                // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.\r\n                tab.header.isActiveExternalChange.subscribe(() => this.onHeaderActiveChanged(tab));\r\n\r\n                // Add the new instance to the list of tabs.\r\n                this.tabs.push(tab);\r\n            });\r\n\r\n        // Assign each tab an index (which denotes the order they physically appear in).\r\n        this._tabHeaders\r\n            .forEach((tH, i) => {\r\n                const tab = this.tabs.find(t => t.header === tH);\r\n                if (tab) {\r\n                    tab.index = i;\r\n                }\r\n            });\r\n\r\n        // Sort the tabs by their index.\r\n        this.tabs.sort((a, b) => a.index - b.index);\r\n\r\n\r\n        if (!this.activeTab) { // Check if there are no current existing active tabs.\r\n            // If so, we must activate the first available tab.\r\n            this.activateFirstTab();\r\n        } else if (!this.tabs.find(t => t === this.activeTab)) { // O'wise check if current active tab has been deleted.\r\n            // If so, we must find the closest.\r\n            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.\r\n            setTimeout(() => this.activateClosestTab(this.activeTab));\r\n        }\r\n\r\n        if (this.tabs.length === 0) {\r\n            // Error if there aren't any tabs in the tabset.\r\n            throw new Error(\"You cannot have no tabs!\");\r\n        }\r\n    }\r\n\r\n    // Fires whenever a tab header's active state is externally changed.\r\n    private onHeaderActiveChanged(tab:Tab):void {\r\n        // If the tab has become activated, but was not previously the active tab:\r\n        if (tab.isActive && this.activeTab !== tab) {\r\n            // Deactivate all of the tabs.\r\n            this.tabs.filter(t => t !== tab).forEach(t => t.isActive = false);\r\n\r\n            // Set the currently active tab to this one.\r\n            this.activeTab = tab;\r\n        }\r\n\r\n        // If the tab has become deactivated, but was previously the active tab:\r\n        if (!tab.isActive && this.activeTab === tab) {\r\n            // Activate the closest tab to it.\r\n            this.activateClosestTab(tab);\r\n        }\r\n    }\r\n\r\n    // Activate the first tab in the set.\r\n    public activateFirstTab():void {\r\n        this.activeTab = this.tabs[0];\r\n    }\r\n\r\n    // Activates the closest available tab to a given one.\r\n    public activateClosestTab(tab:Tab):void {\r\n        let nextAvailable:Tab | undefined;\r\n\r\n        // When the exited tab's index is higher than all available tabs,\r\n        if (tab.index >= this.tabs.length) {\r\n            // Activate the last tab.\r\n            nextAvailable = this.tabs[this.tabs.length - 1];\r\n        }\r\n\r\n        // If that didn't work, try the following cases:\r\n        if (!nextAvailable) {\r\n            if (!this.tabs.find(t => t === tab)) { // When the exited tab no longer exists,\r\n                // Replace it with a tab at the same index.\r\n                nextAvailable = this.tabs[tab.index];\r\n            } else { // Or if the exited tab still exists,\r\n                // Go to the tab immediately to the left.\r\n                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];\r\n            }\r\n        }\r\n\r\n        // However, if the chosen tab is disabled,\r\n        if (nextAvailable.isDisabled) {\r\n            // Activate the closest available tab to it.\r\n            return this.activateClosestTab(nextAvailable);\r\n        }\r\n\r\n        this.activeTab = nextAvailable;\r\n    }\r\n}\r\n"]}