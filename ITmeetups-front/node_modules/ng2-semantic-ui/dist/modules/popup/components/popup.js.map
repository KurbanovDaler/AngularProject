{"version":3,"file":"popup.js","sourceRoot":"","sources":["../../../../src/modules/popup/components/popup.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, ViewChild, ViewContainerRef, ElementRef, EventEmitter, HostListener, HostBinding } from \"@angular/core\";\r\nimport { PositioningService, IDynamicClasses } from \"../../../misc/util/index\";\r\nimport { TransitionController, TransitionDirection, Transition } from \"../../transition/index\";\r\nimport { IPopup } from \"../classes/popup-controller\";\r\nimport { TemplatePopupConfig } from \"../classes/popup-template-controller\";\r\n\r\n@Component({\r\n    selector: \"sui-popup\",\r\n    template: `\r\n<div class=\"ui popup\"\r\n     [ngClass]=\"dynamicClasses\"\r\n     [suiTransition]=\"transitionController\"\r\n     [attr.direction]=\"direction\"\r\n     #container>\r\n\r\n    <ng-container *ngIf=\"!config.template && (!!config.header || !!config.text)\">\r\n        <div class=\"header\" *ngIf=\"config.header\">{{ config.header }}</div>\r\n        <div class=\"content\">{{ config.text }}</div>\r\n    </ng-container>\r\n    <div #templateSibling></div>\r\n\r\n    <sui-popup-arrow *ngIf=\"!config.isBasic\"\r\n                     [placement]=\"positioningService.actualPlacement\"\r\n                     [inverted]=\"config.isInverted\"></sui-popup-arrow>\r\n</div>\r\n`,\r\n    styles: [`\r\n.ui.popup {\r\n    /* Autofit popup to the contents. */\r\n    right: auto;\r\n}\r\n\r\n.ui.animating.popup {\r\n    /* When the popup is animating, it may not initially be in the correct position.\r\n       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.\r\n       Setting pointer-events to none while animating fixes this bug. */\r\n    pointer-events: none;\r\n}\r\n\r\n.ui.popup::before {\r\n    /* Hide the Semantic UI CSS arrow. */\r\n    display: none;\r\n}\r\n\r\n/* Offset popup by 0.75em above and below when placed 'vertically'. */\r\n.ui.popup[direction=\"top\"],\r\n.ui.popup[direction=\"bottom\"] {\r\n    margin-top: 0.75em;\r\n    margin-bottom: 0.75em;\r\n}\r\n\r\n/* Offset popup by 0.75em either side when placed 'horizontally'. */\r\n.ui.popup[direction=\"left\"],\r\n.ui.popup[direction=\"right\"] {\r\n    margin-left: 0.75em;\r\n    margin-right: 0.75em;\r\n}\r\n`]\r\n})\r\nexport class SuiPopup implements IPopup {\r\n    // Config settings for this popup.\r\n    public config:TemplatePopupConfig<any>;\r\n\r\n    public transitionController:TransitionController;\r\n    public positioningService:PositioningService;\r\n\r\n    // Keeps track of whether the popup is open internally.\r\n    private _isOpen:boolean;\r\n    // `setTimeout` timer pointer for cancelling popup close.\r\n    public closingTimeout:number;\r\n\r\n    // Fires when the popup opens (and the animation is completed).\r\n    public onOpen:EventEmitter<void>;\r\n    // Fires when the popup closes (and the animation is completed).\r\n    public onClose:EventEmitter<void>;\r\n\r\n    public get isOpen():boolean {\r\n        return this._isOpen;\r\n    }\r\n\r\n    // `ElementRef` for the positioning subject.\r\n    @ViewChild(\"container\", { read: ViewContainerRef })\r\n    private _container:ViewContainerRef;\r\n\r\n    public set anchor(anchor:ElementRef) {\r\n        // Whenever the anchor is set (which is when the popup is created), recreate the positioning service with the appropriate options.\r\n        this.positioningService = new PositioningService(anchor, this._container.element, this.config.placement, \".dynamic.arrow\");\r\n    }\r\n\r\n    // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.\r\n    public get direction():string | undefined {\r\n        if (this.positioningService) {\r\n            return this.positioningService.actualPlacement.split(\" \").shift();\r\n        }\r\n    }\r\n\r\n    // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.\r\n    public get alignment():string | undefined {\r\n        if (this.positioningService) {\r\n            return this.positioningService.actualPlacement.split(\" \").pop();\r\n        }\r\n    }\r\n\r\n    public get dynamicClasses():IDynamicClasses {\r\n        const classes:IDynamicClasses = {};\r\n        if (this.direction) {\r\n            classes[this.direction] = true;\r\n        }\r\n        if (this.alignment) {\r\n            classes[this.alignment] = true;\r\n        }\r\n        if (this.config.isInverted) {\r\n            classes.inverted = true;\r\n        }\r\n        if (this.config.isBasic) {\r\n            classes.basic = true;\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    // `ViewContainerRef` for the element the template gets injected as a sibling of.\r\n    @ViewChild(\"templateSibling\", { read: ViewContainerRef })\r\n    public templateSibling:ViewContainerRef;\r\n\r\n    @HostBinding(\"attr.tabindex\")\r\n    private _tabindex:number;\r\n\r\n    constructor(public elementRef:ElementRef) {\r\n        this.transitionController = new TransitionController(false);\r\n\r\n        this._isOpen = false;\r\n\r\n        this.onOpen = new EventEmitter<void>();\r\n        this.onClose = new EventEmitter<void>();\r\n\r\n        this._tabindex = 0;\r\n    }\r\n\r\n    public open():void {\r\n        // Only attempt to open if currently closed.\r\n        if (!this.isOpen) {\r\n            // Cancel the closing timer.\r\n            clearTimeout(this.closingTimeout);\r\n\r\n            // Cancel all other transitions, and initiate the opening transition.\r\n            this.transitionController.stopAll();\r\n            this.transitionController.animate(\r\n                new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, () => {\r\n                    // Focus any element with [autofocus] attribute.\r\n                    const autoFocus = this.elementRef.nativeElement.querySelector(\"[autofocus]\") as HTMLElement | null;\r\n                    if (autoFocus) {\r\n                        // Autofocus after the browser has had time to process other event handlers.\r\n                        setTimeout(() => autoFocus.focus(), 10);\r\n                        // Try to focus again when the modal has opened so that autofocus works in IE11.\r\n                        setTimeout(() => autoFocus.focus(), this.config.transitionDuration);\r\n                    }\r\n                }));\r\n\r\n            // Refresh the popup position after a brief delay to allow for browser processing time.\r\n            this.positioningService.placement = this.config.placement;\r\n            setTimeout(() => this.positioningService.update());\r\n\r\n            // Finally, set the popup to be open.\r\n            this._isOpen = true;\r\n            this.onOpen.emit();\r\n        }\r\n    }\r\n\r\n    public toggle():void {\r\n        if (!this.isOpen) {\r\n            return this.open();\r\n        }\r\n\r\n        return this.close();\r\n    }\r\n\r\n    public close():void {\r\n        // Only attempt to close if currently open.\r\n        if (this.isOpen) {\r\n            // Cancel all other transitions, and initiate the closing transition.\r\n            this.transitionController.stopAll();\r\n            this.transitionController.animate(\r\n                new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));\r\n\r\n            // Cancel the closing timer.\r\n            clearTimeout(this.closingTimeout);\r\n            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.\r\n            this.closingTimeout = window.setTimeout(() => this.onClose.emit(), this.config.transitionDuration);\r\n\r\n            // Finally, set the popup to be closed.\r\n            this._isOpen = false;\r\n        }\r\n    }\r\n\r\n    @HostListener(\"click\", [\"$event\"])\r\n    public onClick(event:MouseEvent):void {\r\n        // Makes sense here, as the popup shouldn't be attached to any DOM element.\r\n        event.stopPropagation();\r\n    }\r\n}\r\n"]}